#include "Cmm.h"
#include "sm/ShouldCompact.h"

stg_compactAddzh (P_ compact, P_ p)
{
    W_ type, info, should;

eval:
    (should) = ccall shouldCompact(compact "ptr", p "ptr");
    if (should == SHOULDCOMPACT_IN_CNF) { return (p); }

    p = UNTAG(p);
    info  = %INFO_PTR(p);
    type = TO_W_(%INFO_TYPE(%STD_INFO(info)));

    switch [0 .. N_CLOSURE_TYPES] type {

    // Unevaluated things must be evaluated first:
    case
        THUNK,
        THUNK_1_0,
        THUNK_0_1,
        THUNK_2_0,
        THUNK_1_1,
        THUNK_0_2,
        THUNK_STATIC,
        AP,
        AP_STACK,
        BLACKHOLE,
        THUNK_SELECTOR : {
        (P_ evald) = call %ENTRY_CODE(info) (p);
        p = evald;
        goto eval;
    }

    // Follow indirections:
    case IND, IND_STATIC: {
        p = StgInd_indirectee(p);
        goto eval;
    }

    // Mutable things are not allowed:
    case
        MVAR_CLEAN,
        MVAR_DIRTY,
        TVAR,
        MUT_ARR_PTRS_CLEAN,
        MUT_ARR_PTRS_DIRTY,
        MUT_ARR_PTRS_CLEAN,
        MUT_VAR_CLEAN,
        MUT_VAR_DIRTY,
        WEAK,
        PRIM,
        MUT_PRIM,
        TSO,
        STACK,
        TREC_CHUNK,
        WHITEHOLE,
        SMALL_MUT_ARR_PTRS_CLEAN,
        SMALL_MUT_ARR_PTRS_DIRTY,
        COMPACT_NFDATA: {
        ccall barf("stg_compactAdd: found mutable closure");
    }

    // We shouldn't see any functions, if this data structure was NFData.
    case
        FUN,
        FUN_1_0,
        FUN_0_1,
        FUN_2_0,
        FUN_1_1,
        FUN_0_2,
        FUN_STATIC,
        BCO,
        PAP: {
        ccall barf("stg_compactAdd: found function");
    }

    case ARR_WORDS: {
        P_ to;
        W_ size;
        size = SIZEOF_StgArrBytes + StgArrBytes_bytes(p);
        ("ptr" to) = ccall allocateForCompact(MyCapability(), compact,
                                              ROUNDUP_BYTES_TO_WDS(size));
        prim %memcpy(to, p, size, 1);
        return (to);
    }

    case
        MUT_ARR_PTRS_FROZEN0,
        MUT_ARR_PTRS_FROZEN: {
        W_ i, size, cards, ptrs;
        size = SIZEOF_StgMutArrPtrs + WDS(StgMutArrPtrs_size(p));
        ptrs = StgMutArrPtrs_ptrs(p);
        cards = SIZEOF_StgMutArrPtrs + WDS(ptrs);
        ("ptr" to) = ccall allocateForCompact(MyCapability(), compact,
                                              BYTES_TO_WDS(size));
        SET_HDR(to, StgHeader_info(p), StgHeader_ccs(p));
        prim %memcpy(to + cards, p + cards , size - cards, 1);
        i = 0;
      loop0:
        if (i < ptrs) {
            (P_ r1) = call stg_compactAddzh(
                compact, W_[p + SIZEOF_StgMutArrPtrs + WDS(i)]);
            P_[to + SIZEOF_StgMutArrPtrs + WDS(i)] = r1;
            i = i + 1;
            goto loop0;
        }
        return (to);
    }

    case
        SMALL_MUT_ARR_PTRS_FROZEN0,
        SMALL_MUT_ARR_PTRS_FROZEN: {
        // (P_ to) = allocateForCompact(cap, compact, size);
        // use prim memcpy
        ccall barf("stg_compactAdd: TODO: SMALL_MUT_ARR_PTRS");
    }

    // Everything else we should copy and evaluate the components:
    case
        CONSTR,
        CONSTR_1_0,
        CONSTR_2_0,
        CONSTR_1_1: {
      constructor:
        W_ i, ptrs, nptrs, size;
        P_ to;
        ptrs  = TO_W_(%INFO_PTRS(%STD_INFO(info)));
        nptrs  = TO_W_(%INFO_NPTRS(%STD_INFO(info)));
        size = BYTES_TO_WDS(SIZEOF_StgHeader) + ptrs + nptrs;

        ("ptr" to) = ccall allocateForCompact(MyCapability() "ptr",
                                              compact "ptr", size);
        SET_HDR(to, StgHeader_info(p), StgHeader_ccs(p));

        // First copy the non-pointers
        if (nptrs > 0) {
            i = ptrs;
        loop1:
            StgClosure_payload(to,i) = StgClosure_payload(p,i);
            i = i + 1;
            if (i < ptrs + nptrs) goto loop1;
        }

        // Next recursively compact and copy the pointers
        i = 0;
      loop2:
        if (i < ptrs) {
            (P_ r) = call stg_compactAddzh(compact, StgClosure_payload(p,i));
            StgClosure_payload(to,i) = r;
            i = i + 1;
            goto loop2;
        }

        return (to);
    }

    // these
    case
        CONSTR_0_1,
        CONSTR_0_2,
        CONSTR_NOCAF: {
        if (should == SHOULDCOMPACT_STATIC) {
            return (p);
        } else {
            goto constructor;
        }
    }}

    return (p);
}

stg_compactSizzezh (P_ compact)
{
   return (0);
}
